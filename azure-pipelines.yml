# azure-pipelines.yml
trigger:
  branches:
    include: [ main ]

pr:
  branches:
    include: [ main ]

pool:
  name: Default          # your self-hosted agent pool (SHIVA)

variables:
  # === Azure resource names / config ===
  azureSubscription: 'AzureRM-ACR'        # Azure RM service connection (has rights on RG/AKS/ACR)
  aksServiceConnection: 'AKSServiceConnection'   # Kubernetes connection (namespace-scoped is fine)
  aksResourceGroup: 'rg-hw-aks-dev'
  aksClusterName: 'aks-hw-dev'

  acrName: 'hwacrdev001'
  acrLoginServer: 'hwacrdev001.azurecr.io'

  imageRepository: 'aks-java-api'         # repository name in ACR
  tag: '$(Build.BuildId)'                 # image tag

  k8sNamespace: 'demo'                    # target namespace

  # (Optional) SonarQube
  enableSonar: 'false'                    # 'true' to enable, requires service connection name below
  sonarServiceConnection: 'SonarQube Server local connection'

stages:
# ─────────────────────────────────────────────────────────────────────────────
# 1) Build & Test (JDK 17 via JavaToolInstaller)
# ─────────────────────────────────────────────────────────────────────────────
- stage: build_test
  displayName: 'Build & Test'
  jobs:
  - job: maven
    displayName: 'Maven build & tests'
    steps:
    - checkout: self

    # Install Temurin JDK 17 on the agent
    - task: JavaToolInstaller@0
      displayName: 'Install Temurin JDK 17'
      inputs:
        versionSpec: '17'
        jdkArchitectureOption: 'x64'
        jdkSourceOption: 'Microsoft'    # downloads Adoptium Temurin via Microsoft Distribution

    # (Optional) SonarQube
    - ${{ if eq(variables.enableSonar, 'true') }}:
      - task: SonarQubePrepare@5
        displayName: 'Prepare SonarQube Analysis'
        inputs:
          SonarQube: '$(sonarServiceConnection)'
          scannerMode: 'Other'
          configMode: 'manual'
          extraProperties: |
            sonar.projectKey=$(imageRepository)
            sonar.projectName=$(imageRepository)
            sonar.sourceEncoding=UTF-8
            sonar.java.source=17

    - task: Maven@4
      displayName: 'Maven clean verify (tests + JaCoCo)'
      inputs:
        mavenPomFile: 'pom.xml'
        goals: 'clean verify'
        options: '-Dmaven.test.failure.ignore=false'
        publishJUnitResults: true
        testResultsFiles: '**/surefire-reports/TEST-*.xml'
        codeCoverageToolOption: JaCoCo
        javaHomeOption: 'JDKVersion'
        jdkVersionOption: '1.17'
        mavenOptions: '-Xmx2048m'

    - ${{ if eq(variables.enableSonar, 'true') }}:
      - task: SonarQubeAnalyze@5
        displayName: 'Run SonarQube Analysis'
      - task: SonarQubePublish@5
        displayName: 'Publish Quality Gate'
        inputs:
          pollingTimeoutSec: '300'

# ─────────────────────────────────────────────────────────────────────────────
# 2) Build & Push image in ACR (server-side) using az acr build
#    -> avoid local docker / WSL. Force PowerShell script.
# ─────────────────────────────────────────────────────────────────────────────
- stage: acr_build
  displayName: 'Build image in ACR (server-side)'
  dependsOn: build_test
  condition: succeeded()
  jobs:
  - job: acr
    displayName: 'ACR build: $(imageRepository):$(tag)'
    steps:
    - checkout: self

    - task: AzureCLI@2
      displayName: 'az acr build → $(imageRepository):$(tag)'
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: pscore
        scriptLocation: inlineScript
        inlineScript: |
          Write-Host "Building image on ACR (server-side)"
          $img = "$(acrLoginServer)/$(imageRepository):$(tag)"
          az acr build `
            --registry $(acrName) `
            --image   $img `
            --file    "$(Build.SourcesDirectory)\Dockerfile" `
            "$(Build.SourcesDirectory)"
          Write-Host "Built: $img"
      # No container on agent, no WSL needed thanks to pscore + server-side build

# ─────────────────────────────────────────────────────────────────────────────
# 3) Deploy to AKS
#    3.1 Create namespace using cluster-admin (Option A, via AzureCLI@2)
#    3.2 Then deploy with the AKS service connection (namespace-scoped OK)
# ─────────────────────────────────────────────────────────────────────────────
- stage: deploy
  displayName: 'Deploy to AKS'
  dependsOn: acr_build
  condition: succeeded()
  jobs:
  - deployment: k8s
    displayName: 'K8s deploy & rollout'
    environment: 'aks-dev'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self

          # 3.1 Ensure namespace exists using cluster-admin kubeconfig
          - task: AzureCLI@2
            displayName: 'Create namespace $(k8sNamespace) (cluster-admin)'
            inputs:
              azureSubscription: '$(azureSubscription)'
              scriptType: pscore
              scriptLocation: inlineScript
              inlineScript: |
                az aks get-credentials `
                  --resource-group $(aksResourceGroup) `
                  --name $(aksClusterName) `
                  --admin `
                  --overwrite-existing

                if (kubectl get ns $(k8sNamespace) -o name 2>$null) {
                  Write-Host "Namespace $(k8sNamespace) already exists."
                } else {
                  kubectl create ns $(k8sNamespace)
                  Write-Host "Namespace $(k8sNamespace) created."
                }

          # (Optional) runtime secret example (uses AKS connection / ns scope)
          # Uncomment if you actually need it:
          # - task: KubernetesManifest@1
          #   displayName: 'Create/Update app secret'
          #   inputs:
          #     action: createSecret
          #     kubernetesServiceConnection: '$(aksServiceConnection)'
          #     namespace: '$(k8sNamespace)'
          #     secretType: generic
          #     secretName: 'app-secrets'
          #     secretArguments: |
          #       --from-literal=APP_MESSAGE=$(APP_MESSAGE)

          # 3.2 Deploy manifests with the AKS service connection
          - task: KubernetesManifest@1
            displayName: 'Deploy app + service'
            inputs:
              action: deploy
              kubernetesServiceConnection: '$(aksServiceConnection)'
              namespace: '$(k8sNamespace)'
              manifests: |
                k8s/deployment.yaml
                k8s/service.yaml
              containers: |
                $(acrLoginServer)/$(imageRepository):$(tag)
              # If your deployment.yaml still has token placeholders, you can add:
              # replacements: |
              #   k8s/deployment.yaml:${REPLICAS}=1

          - task: Kubernetes@1
            displayName: 'Rollout status (wait until Ready)'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceEndpoint: '$(aksServiceConnection)'
              namespace: '$(k8sNamespace)'
              command: 'rollout'
              arguments: 'status deploy/aks-java-api --timeout=300s'

          - task: Kubernetes@1
            displayName: 'Show service (external IP)'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceEndpoint: '$(aksServiceConnection)'
              namespace: '$(k8sNamespace)'
              command: 'get'
              arguments: 'svc aks-java-api -o wide'
