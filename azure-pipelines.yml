# ===========================
# aks-java-api CI/CD to AKS
# - Java build & tests + Sonar
# - ACR cloud build (no local Docker)
# - AKS deploy + rollout wait
# ===========================

trigger:
  branches: { include: [ main ] }

pr:
  branches: { include: [ main ] }

# Your self-hosted agent pool
pool:
  name: Default

# -------- Variables (edit to your names) --------
variables:
  # ACR
  acrName: hwacrdev001                    # ACR resource name (not FQDN)
  acrLoginServer: hwacrdev001.azurecr.io  # ACR login server
  imageRepository: aks-java-api
  tag: '$(Build.BuildId)'

  # AKS / K8s
  kubernetesServiceConnection: AKSServiceConnection  # Kubernetes/AKS service connection name
  k8sNamespace: demo

  # Azure RM service connection with access to the ACR resource
  azureSubscription: AzureRM-ACR    # <-- CHANGE to your ARM service connection name

  # Optional: message that becomes a secret in K8s
  APP_MESSAGE: "Hello from KeyVault/var"

# ========================= STAGES =========================

# 1) Build, test, and Sonar
stages:
- stage: Build_Test_Scan
  displayName: "Build, Test & Sonar"
  jobs:
  - job: MavenBuild
    displayName: "Maven + Tests + Sonar"
    steps:
    - checkout: self

    # Make sure JDK 17 is present even on a clean/self-hosted agent
    - task: JavaToolInstaller@0
      displayName: "Install JDK 17"
      inputs:
        versionSpec: '17'
        jdkArchitectureOption: x64
        jdkSourceOption: PreInstalled

    - task: SonarQubePrepare@5
      displayName: "Prepare SonarQube"
      inputs:
        SonarQube: "SonarQube Server local connection"   # must match your service connection
        scannerMode: "Other"
        configMode: "manual"
        extraProperties: |
          sonar.projectKey=aks-java-api
          sonar.projectName=aks-java-api
          sonar.sourceEncoding=UTF-8
          sonar.java.source=17
          sonar.coverage.jacoco.xmlReportPaths=**/jacoco*.xml

    - task: Maven@4
      displayName: "Maven clean verify (tests + JaCoCo)"
      inputs:
        mavenPomFile: pom.xml
        goals: clean verify
        publishJUnitResults: true
        testResultsFiles: "**/surefire-reports/TEST-*.xml"
        codeCoverageToolOption: JaCoCo
        javaHomeOption: Path
        jdkDirectory: "$(JAVA_HOME)"     # provided by JavaToolInstaller
        mavenOptions: "-Xmx1024m"

    - task: SonarQubeAnalyze@5
      displayName: "Run Sonar Analysis"

    - task: SonarQubePublish@5
      displayName: "Publish Quality Gate"
      inputs:
        pollingTimeoutSec: 300

# 2) Cloud build the image in ACR (no local Docker required)
- stage: Build_Push_Image
  displayName: "ACR Build & Push"
  dependsOn: Build_Test_Scan
  condition: succeeded()
  jobs:
  - job: ACRBuild
    displayName: "az acr build"
    steps:
    - checkout: self

    - task: AzureCLI@2
      displayName: "ACR build: $(imageRepository):$(tag)"
      inputs:
        azureSubscription: "$(azureSubscription)"
        scriptType: pscore
        scriptLocation: inlineScript
        inlineScript: |
          Write-Host "Using ACR: $(acrName)"
          # Build from repository root; Dockerfile at ./Dockerfile
          az acr build `
            --registry "$(acrName)" `
            --image "$(imageRepository):$(tag)" `
            --image "$(imageRepository):latest" `
            --file "Dockerfile" `
            .
          # Expose full image reference for next stage (optional)
          $fullImage = "$(acrLoginServer)/$(imageRepository):$(tag)"
          Write-Host "##vso[task.setvariable variable=BuiltImage;isOutput=true]$fullImage"
      name: acr   # <-- output reference: Build_Push_Image.ACRBuild.acr.BuiltImage

# 3) Deploy to AKS and wait for rollout
- stage: Deploy_AKS
  displayName: "Deploy to AKS (demo)"
  dependsOn: Build_Push_Image
  condition: succeeded()
  variables:
    # You can also use stage output:
    # builtImage: $[ stageDependencies.Build_Push_Image.ACRBuild.outputs['acr.BuiltImage'] ]
    builtImage: '$(acrLoginServer)/$(imageRepository):$(tag)'
  jobs:
  - deployment: Deploy
    environment: "aks-dev"
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self

          # Ensure namespace exists (idempotent)
          - task: Kubernetes@1
            displayName: "Ensure namespace $(k8sNamespace)"
            inputs:
              connectionType: Kubernetes Service Connection
              kubernetesServiceEndpoint: "$(kubernetesServiceConnection)"
              command: apply
              useConfigurationFile: true
              configurationType: inline
              inline: |
                apiVersion: v1
                kind: Namespace
                metadata:
                  name: $(k8sNamespace)

          # Optional: create/refresh app secret
          - task: KubernetesManifest@1
            displayName: "Create/Update app secret"
            inputs:
              action: createSecret
              kubernetesServiceConnection: "$(kubernetesServiceConnection)"
              namespace: "$(k8sNamespace)"
              secretType: generic
              secretName: "app-secrets"
              secretArguments: |
                --from-literal=APP_MESSAGE=$(APP_MESSAGE)

          # Deploy manifests and override image
          - task: KubernetesManifest@1
            displayName: "Deploy app + service"
            inputs:
              action: deploy
              kubernetesServiceConnection: "$(kubernetesServiceConnection)"
              namespace: "$(k8sNamespace)"
              manifests: |
                k8s/deployment.yaml
                k8s/service.yaml
              containers: |
                $(builtImage)

          # Wait for rollout to complete
          - task: Kubernetes@1
            displayName: "Rollout status"
            inputs:
              connectionType: Kubernetes Service Connection
              kubernetesServiceEndpoint: "$(kubernetesServiceConnection)"
              namespace: "$(k8sNamespace)"
              command: rollout
              arguments: "status deploy/aks-java-api --timeout=300s"

          # Show external service details (IP/port)
          - task: Kubernetes@1
            displayName: "Get service"
            inputs:
              connectionType: Kubernetes Service Connection
              kubernetesServiceEndpoint: "$(kubernetesServiceConnection)"
              namespace: "$(k8sNamespace)"
              command: get
              arguments: "svc aks-java-api -o wide"
