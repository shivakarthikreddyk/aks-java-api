# =========================
# aks-java-api - CI/CD to AKS via ACR build (Option C)
# =========================

trigger:
  branches: { include: [ main ] }

pr:
  branches: { include: [ main ] }

# Use your self-hosted pool where the SHIVA agent is registered
pool:
  name: Default

variables:
  # ---- CHANGE THESE TWO NAMES TO MATCH YOUR DEVOPS SERVICE CONNECTIONS ----
  azureRmServiceConnection: 'sc-azure-rg-hw-aks-dev'   # Azure Resource Manager service connection (exact name)
  kubernetesServiceConnection: 'AKSServiceConnection'  # Kubernetes service connection (exact name)

  # ---- ACR / Image / AKS Settings ----
  acrName: 'hwacrdev001'
  acrLoginServer: 'hwacrdev001.azurecr.io'
  imageRepository: 'aks-java-api'
  k8sNamespace: 'demo'
  tag: '$(Build.BuildId)'

  # (Optional) Sonar settings – requires a SonarQube service connection with this name
  sonarConnection: 'SonarQube Server local connection'
  mavenOpts: '-Xmx3072m'

stages:
# ───────────────────────────────────────────────────────────────────────────────
# 1) Build, Test & (optional) Sonar
# ───────────────────────────────────────────────────────────────────────────────
- stage: Build_Test_Scan
  displayName: 'Build, Test & Sonar Scan'
  jobs:
  - job: MavenBuild
    displayName: 'Maven build & tests'
    steps:
    - checkout: self

    # Ensure JDK 17 is present even on a clean/self-hosted agent
    - task: JavaToolInstaller@0
      displayName: 'Install JDK 17 (Temurin)'
      inputs:
        versionSpec: '17'
        jdkArchitectureOption: 'x64'
        jdkSourceOption: 'PreInstalled'   # If your agent already has 17, keep this
        # If your agent does NOT have Java 17, switch the previous line to:
        # jdkSourceOption: 'AzureStorage'
        # and configure the storage inputs; or just install JDK on the agent.

    # (Optional) SonarQube — remove this block if you don’t use Sonar
    - task: SonarQubePrepare@5
      displayName: 'Prepare SonarQube Analysis'
      inputs:
        SonarQube: '$(sonarConnection)'
        scannerMode: 'Other'
        configMode: 'manual'
        extraProperties: |
          sonar.projectKey=aks-java-api
          sonar.projectName=aks-java-api
          sonar.sourceEncoding=UTF-8
          sonar.java.source=17
          sonar.coverage.jacoco.xmlReportPaths=**/jacoco*.xml

    - task: Maven@4
      displayName: 'Maven clean verify (tests + JaCoCo)'
      inputs:
        mavenPomFile: 'pom.xml'
        goals: 'clean verify'
        options: '-Dmaven.test.failure.ignore=false'
        publishJUnitResults: true
        testResultsFiles: '**/surefire-reports/TEST-*.xml'
        codeCoverageToolOption: 'JaCoCo'
        javaHomeOption: 'JDKVersion'
        jdkVersionOption: '1.17'
        mavenOptions: '$(mavenOpts)'

    # (Optional) SonarQube — remove if unused
    - task: SonarQubeAnalyze@5
      displayName: 'Run SonarQube Analysis'

    # (Optional) SonarQube — remove if unused
    - task: SonarQubePublish@5
      displayName: 'Publish Quality Gate'
      inputs:
        pollingTimeoutSec: '300'

# ───────────────────────────────────────────────────────────────────────────────
# 2) Build & Push Image using ACR Build (Option C)
#    This runs the build on Azure ACR builder (no local Docker needed)
# ───────────────────────────────────────────────────────────────────────────────
- stage: ACR_Build
  displayName: 'Build image in ACR (az acr build)'
  dependsOn: Build_Test_Scan
  condition: succeeded()
  jobs:
  - job: ACRBuild
    displayName: 'ACR build: $(imageRepository):$(tag)'
    steps:
    - checkout: self

    # Uses the Azure RM service connection name EXACTLY as created in DevOps
    - task: AzureCLI@2
      displayName: 'ACR build (aks-java-api:$(tag))'
      inputs:
        azureSubscription: '$(azureRmServiceConnection)'
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -e
          echo "Building image with ACR Build..."
          az acr build \
            --registry $(acrName) \
            --image $(imageRepository):$(tag) \
            .
          echo "Build finished."

# ───────────────────────────────────────────────────────────────────────────────
# 3) Deploy to AKS (manifests) + rollout wait
# ───────────────────────────────────────────────────────────────────────────────
- stage: Deploy_AKS
  displayName: 'Deploy to AKS (demo)'
  dependsOn: ACR_Build
  condition: succeeded()
  jobs:
  - deployment: K8sDeploy
    displayName: 'K8s deploy'
    environment: 'aks-dev'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self

          # Ensure namespace exists (idempotent)
          - task: Kubernetes@1
            displayName: 'Ensure namespace $(k8sNamespace)'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceEndpoint: '$(kubernetesServiceConnection)'
              command: 'apply'
              useConfigurationFile: true
              configurationType: 'inline'
              inline: |
                apiVersion: v1
                kind: Namespace
                metadata:
                  name: $(k8sNamespace)

          # Optional: runtime secret (set variable APP_MESSAGE in pipeline Lib/Variables or Runtime)
          - task: KubernetesManifest@1
            displayName: 'Create/Update app secret'
            inputs:
              action: 'createSecret'
              kubernetesServiceConnection: '$(kubernetesServiceConnection)'
              namespace: '$(k8sNamespace)'
              secretType: 'generic'
              secretName: 'app-secrets'
              secretArguments: |
                --from-literal=APP_MESSAGE=$(APP_MESSAGE)

          # Deploy Deployment + Service
          - task: KubernetesManifest@1
            displayName: 'Deploy manifests'
            inputs:
              action: 'deploy'
              kubernetesServiceConnection: '$(kubernetesServiceConnection)'
              namespace: '$(k8sNamespace)'
              manifests: |
                k8s/deployment.yaml
                k8s/service.yaml
              # Let the task substitute the container image in the deployment
              containers: |
                $(acrLoginServer)/$(imageRepository):$(tag)

          # Block until rollout completes
          - task: Kubernetes@1
            displayName: 'Rollout status (wait)'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceEndpoint: '$(kubernetesServiceConnection)'
              namespace: '$(k8sNamespace)'
              command: 'rollout'
              arguments: 'status deploy/aks-java-api --timeout=300s'

          # Show service to get external IP (if LoadBalancer)
          - task: Kubernetes@1
            displayName: 'Show service'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceEndpoint: '$(kubernetesServiceConnection)'
              namespace: '$(k8sNamespace)'
              command: 'get'
              arguments: 'svc aks-java-api -o wide'
