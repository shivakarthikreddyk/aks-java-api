# ===================== Azure Pipelines for aks-java-api ======================
# Self-hosted agent (Default). Installs JDK 17, builds/tests with Maven,
# builds the Docker image remotely in ACR, then deploys to AKS.

trigger:
  branches:
    include: [ main ]

pr:
  branches:
    include: [ main ]

pool:
  name: Default              # your self-hosted agent pool (SHIVA)

variables:
  # ---- image & registry ----
  acrName: 'hwacrdev001'                         # ACR resource name (not FQDN)
  acrLoginServer: 'hwacrdev001.azurecr.io'       # ACR login server (FQDN)
  imageRepository: 'aks-java-api'
  tag: '$(Build.BuildId)'

  # ---- service connections ----
  azureSubscription: 'AzureRM-ACR'               # ARM service connection (for az acr build)
  kubernetesServiceConnection: 'AKSServiceConnection'

  # ---- k8s ----
  k8sNamespace: 'demo'

stages:
# ============================= 1) Build & Test ==============================
- stage: Build_Test_Scan
  displayName: 'Build, Test & (optional) Sonar'
  jobs:
  - job: MavenBuild
    displayName: 'Maven build & tests'
    steps:
      - checkout: self

      # --- Ensure JDK 17 is present on the self-hosted agent ---
      # This installs Temurin JDK 17 (if missing) and exposes JAVA_HOME/PATH
      - powershell: |
          Write-Host "Checking Java..."
          $java = & java -version 2>&1
          if ($LASTEXITCODE -ne 0) {
            Write-Host "Java not found. Installing Temurin 17 with Chocolatey..."
            choco install -y temurin17
          } else {
            Write-Host $java
          }
          $jdk = Get-ChildItem "C:\Program Files\Eclipse Adoptium" -Directory `
                | Where-Object { $_.Name -like "jdk-17*" } `
                | Select-Object -First 1 -ExpandProperty FullName
          if (-not $jdk) {
            throw "JDK 17 not found after install."
          }
          Write-Host "Found JDK at: $jdk"
          # Export for the rest of this job
          Write-Host "##vso[task.setvariable variable=JAVA_HOME]$jdk"
          $newPath = "$jdk\bin;$env:PATH"
          Write-Host "##vso[task.setvariable variable=PATH]$newPath"
          # quick sanity check
          & "$jdk\bin\java.exe" -version
        displayName: 'Install/Detect JDK 17 (Temurin)'

      # ---- (Optional) SonarQube Prepare ----
      # Comment out this block if you don't use SonarQube
      - task: SonarQubePrepare@5
        displayName: 'Prepare SonarQube Analysis'
        inputs:
          SonarQube: 'SonarQube Server local connection'
          scannerMode: 'Other'
          configMode: 'manual'
          extraProperties: |
            sonar.projectKey=aks-java-api
            sonar.projectName=aks-java-api
            sonar.sourceEncoding=UTF-8
            sonar.java.source=17
            sonar.coverage.jacoco.xmlReportPaths=**/jacoco*.xml

      # ---- Maven Build & Tests (will use JAVA on PATH) ----
      - task: Maven@4
        displayName: 'Maven clean verify (tests + JaCoCo)'
        inputs:
          mavenPomFile: 'pom.xml'
          goals: 'clean verify'
          options: '-Dmaven.test.failure.ignore=false'
          publishJUnitResults: true
          testResultsFiles: '**/surefire-reports/TEST-*.xml'
          codeCoverageToolOption: 'JaCoCo'
          javaHomeOption: 'Path'     # use the PATH we set above

      # ---- (Optional) SonarQube Analyze & Gate ----
      - task: SonarQubeAnalyze@5
        displayName: 'Run SonarQube Analysis'

      - task: SonarQubePublish@5
        displayName: 'Publish Quality Gate'
        inputs:
          pollingTimeoutSec: '300'

# ========================= 2) Remote build in ACR ===========================
- stage: ACR_Build
  displayName: 'Build image in ACR (az acr build)'
  dependsOn: Build_Test_Scan
  condition: succeeded()
  jobs:
  - job: ACRRemoteBuild
    displayName: 'ACR build: $(imageRepository):$(tag)'
    steps:
      - checkout: self

      # Uses Azure CLI with your ARM service connection
      - task: AzureCLI@2
        displayName: 'az acr build -> $(acrName)/$(imageRepository):$(tag)'
        inputs:
          azureSubscription: '$(azureSubscription)'
          scriptType: 'ps'
          scriptLocation: 'inlineScript'
          inlineScript: |
            az --version
            Write-Host "Building in ACR..."
            az acr build `
              --registry $(acrName) `
              --image $(imageRepository):$(tag) `
              .
            Write-Host "ACR build submitted. Image: $(acrLoginServer)/$(imageRepository):$(tag)"

# ============================= 3) Deploy to AKS =============================
- stage: Deploy_AKS
  displayName: 'Deploy to AKS (demo)'
  dependsOn: ACR_Build
  condition: succeeded()
  variables:
    imageRef: '$(acrLoginServer)/$(imageRepository):$(tag)'
  jobs:
  - deployment: K8sDeploy
    displayName: 'K8s deploy'
    environment: 'aks-dev'   # optional DevOps environment
    strategy:
      runOnce:
        deploy:
          steps:
            - checkout: self

            # Ensure the namespace exists (idempotent)
            - task: Kubernetes@1
              displayName: 'Ensure namespace $(k8sNamespace)'
              inputs:
                connectionType: 'Kubernetes Service Connection'
                kubernetesServiceEndpoint: '$(kubernetesServiceConnection)'
                command: 'apply'
                useConfigurationFile: true
                configurationType: 'inline'
                inline: |
                  apiVersion: v1
                  kind: Namespace
                  metadata:
                    name: $(k8sNamespace)

            # (Optional) Create/refresh a simple secret for APP_MESSAGE
            - task: KubernetesManifest@1
              displayName: 'Create/Update app secret'
              inputs:
                action: 'createSecret'
                kubernetesServiceConnection: '$(kubernetesServiceConnection)'
                namespace: '$(k8sNamespace)'
                secretType: 'generic'
                secretName: 'app-secrets'
                secretArguments: |
                  --from-literal=APP_MESSAGE=Hello-from-DevOps

            # Apply manifests; container image is injected; replace any tokens if needed
            - task: KubernetesManifest@1
              displayName: 'Deploy app + service'
              inputs:
                action: 'deploy'
                kubernetesServiceConnection: '$(kubernetesServiceConnection)'
                namespace: '$(k8sNamespace)'
                manifests: |
                  k8s/deployment.yaml
                  k8s/service.yaml
                containers: |
                  $(imageRef)
                # Uncomment replacements below if your deployment.yaml contains ${REPLICAS} etc.
                # replacements: |
                #   k8s/deployment.yaml:${REPLICAS}=1

            # Wait for the rollout to complete
            - task: Kubernetes@1
              displayName: 'Rollout status'
              inputs:
                connectionType: 'Kubernetes Service Connection'
                kubernetesServiceEndpoint: '$(kubernetesServiceConnection)'
                namespace: '$(k8sNamespace)'
                command: 'rollout'
                arguments: 'status deploy/aks-java-api --timeout=300s'

            # Show service details (external IP)
            - task: Kubernetes@1
              displayName: 'Show service'
              inputs:
                connectionType: 'Kubernetes Service Connection'
                kubernetesServiceEndpoint: '$(kubernetesServiceConnection)'
                namespace: '$(k8sNamespace)'
                command: 'get'
                arguments: 'svc aks-java-api -o wide'
