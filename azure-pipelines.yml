# Azure Pipelines – self-hosted agent (Default pool) + JDK 17 installed in-pipeline

trigger:
  branches:
    include: [ main ]

pr:
  branches:
    include: [ main ]

# Use your self-hosted pool/agent
pool:
  name: Default   # (SHIVA is in this pool)

variables:
  # Image/registry/cluster
  imageRepository: 'aks-java-api'
  acrLoginServer: 'hwacrdev001.azurecr.io'      # <your-acr>.azurecr.io
  acrServiceConnection: 'ACRServiceConnection'  # Docker Registry service connection to ACR
  kubernetesServiceConnection: 'AKSServiceConnection'
  k8sNamespace: 'demo'
  tag: '$(Build.BuildId)'

  # Sonar (keep as you used)
  sonarConnection: 'SonarQube Server local connection'

stages:
# ─────────────────────────────────────────────────────────────────────────────
# 1) Build + Test + Sonar (JDK 17 installed via pipeline on self-hosted agent)
# ─────────────────────────────────────────────────────────────────────────────
- stage: Build_Test_Scan
  displayName: 'Build, Test & Sonar Scan'
  jobs:
  - job: MavenBuild
    displayName: 'Maven build & tests'
    steps:
    - checkout: self

    # Install Temurin JDK 17 on Windows self-hosted agent (requires Chocolatey)
    - task: PowerShell@2
      displayName: 'Install JDK 17 (Temurin) & set JAVA_HOME/PATH'
      inputs:
        targetType: 'inline'
        script: |
          choco install -y temurin17
          $jdk = Get-ChildItem 'C:\Program Files\Eclipse Adoptium\' -Directory `
                  | Where-Object { $_.Name -like 'jdk-17*' } `
                  | Sort-Object LastWriteTime -Descending `
                  | Select-Object -First 1
          if (-not $jdk) {
            Write-Error "JDK 17 not found after install."
            exit 1
          }
          Write-Host "Found JDK: $($jdk.FullName)"
          # Make it available to following tasks in this job
          Write-Host "##vso[task.setvariable variable=JAVA_HOME]$($jdk.FullName)"
          Write-Host "##vso[task.setvariable variable=JAVA_HOME_17_X64]$($jdk.FullName)"
          Write-Host "##vso[task.prependpath]$($jdk.FullName)\bin"
          java -version

    # Sonar – prepare
    - task: SonarQubePrepare@5
      displayName: 'Prepare SonarQube Analysis'
      inputs:
        SonarQube: '$(sonarConnection)'
        scannerMode: 'Other'
        configMode: 'manual'
        extraProperties: |
          sonar.projectKey=aks-java-api
          sonar.projectName=aks-java-api
          sonar.sourceEncoding=UTF-8
          sonar.java.source=17
          sonar.coverage.jacoco.xmlReportPaths=**/jacoco*.xml

    # Build & test (Maven uses the JDK on PATH we just installed)
    - task: Maven@4
      displayName: 'Maven clean verify (tests + JaCoCo)'
      inputs:
        mavenPomFile: 'pom.xml'
        goals: 'clean verify'
        options: '-Dmaven.test.failure.ignore=false'
        publishJUnitResults: true
        testResultsFiles: '**/surefire-reports/TEST-*.xml'
        codeCoverageToolOption: 'JaCoCo'
        javaHomeOption: 'Path'    # IMPORTANT: use the JAVA on PATH we set above

    # Sonar – analyze & publish gate
    - task: SonarQubeAnalyze@5
      displayName: 'Run SonarQube Analysis'

    - task: SonarQubePublish@5
      displayName: 'Publish Quality Gate'
      inputs:
        pollingTimeoutSec: '300'

# ─────────────────────────────────────────────────────────────────────────────
# 2) Build & Push Docker image to ACR
# ─────────────────────────────────────────────────────────────────────────────
- stage: Build_Push_Image
  displayName: 'Build & Push Docker Image'
  dependsOn: Build_Test_Scan
  condition: succeeded()
  jobs:
  - job: ACRBuild
    displayName: 'Docker build & push'
    steps:
    - checkout: self

    # Login to ACR via service connection
    - task: Docker@2
      displayName: 'Login to ACR'
      inputs:
        command: 'login'
        containerRegistry: '$(acrServiceConnection)'

    # Build the image locally (agent must have Docker Desktop running & agent running elevated)
    - task: Docker@2
      displayName: 'Build image'
      inputs:
        command: 'build'
        repository: '$(imageRepository)'
        dockerfile: '**/Dockerfile'
        tags: |
          $(tag)

    # Push the image to ACR
    - task: Docker@2
      displayName: 'Push image to ACR'
      inputs:
        command: 'push'
        repository: '$(imageRepository)'
        containerRegistry: '$(acrServiceConnection)'
        tags: |
          $(tag)

# ─────────────────────────────────────────────────────────────────────────────
# 3) Deploy to AKS (wait for rollout)
# ─────────────────────────────────────────────────────────────────────────────
- stage: Deploy_AKS
  displayName: 'Deploy to AKS (demo)'
  dependsOn: Build_Push_Image
  condition: succeeded()
  jobs:
  - deployment: K8sDeploy
    displayName: 'K8s deploy'
    environment: 'aks-dev'
    strategy:
      runOnce:
        deploy:
          steps:
          - checkout: self

          # Idempotent namespace creation
          - task: Kubernetes@1
            displayName: 'Ensure namespace exists'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceEndpoint: '$(kubernetesServiceConnection)'
              command: 'apply'
              useConfigurationFile: true
              configurationType: 'inline'
              inline: |
                apiVersion: v1
                kind: Namespace
                metadata:
                  name: $(k8sNamespace)

          # Optional: create/update secret
          - task: KubernetesManifest@1
            displayName: 'Create/Update app secret'
            inputs:
              action: 'createSecret'
              kubernetesServiceConnection: '$(kubernetesServiceConnection)'
              namespace: '$(k8sNamespace)'
              secretType: 'generic'
              secretName: 'app-secrets'
              secretArguments: |
                --from-literal=APP_MESSAGE=$(APP_MESSAGE)

          # Deploy deployment + service; inject image tag
          - task: KubernetesManifest@1
            displayName: 'Deploy app + service'
            inputs:
              action: 'deploy'
              kubernetesServiceConnection: '$(kubernetesServiceConnection)'
              namespace: '$(k8sNamespace)'
              manifests: |
                k8s/deployment.yaml
                k8s/service.yaml
              containers: |
                $(acrLoginServer)/$(imageRepository):$(tag)

          # Wait for rollout to finish
          - task: Kubernetes@1
            displayName: 'Rollout status (wait until Ready)'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceEndpoint: '$(kubernetesServiceConnection)'
              namespace: '$(k8sNamespace)'
              command: 'rollout'
              arguments: 'status deploy/aks-java-api --timeout=300s'

          # Print Service info (External IP if LoadBalancer)
          - task: Kubernetes@1
            displayName: 'Show service (external IP)'
            inputs:
              connectionType: 'Kubernetes Service Connection'
              kubernetesServiceEndpoint: '$(kubernetesServiceConnection)'
              namespace: '$(k8sNamespace)'
              command: 'get'
              arguments: 'svc aks-java-api -o wide'
