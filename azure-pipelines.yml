# ────────────────────────────────────────────────────────────────────────────────
# Azure Pipelines: Maven → ACR build (server-side) → AKS deploy + rollout wait
# Pool: self-hosted 'Default' (agent name SHIVA)
# ────────────────────────────────────────────────────────────────────────────────
trigger:
  branches:
    include: [ main ]

pr:
  branches:
    include: [ main ]

pool:
  name: Default   # your self-hosted pool with agent SHIVA

variables:
  # ---- App / image
  imageRepository: 'aks-java-api'
  tag: '$(Build.BuildId)'

  # ---- ACR
  acrName: 'hwacrdev001'                   # ACR resource name (not FQDN)
  acrLoginServer: 'hwacrdev001.azurecr.io' # shown in ACR Overview

  # ---- AKS / K8s
  k8sNamespace: 'demo'

  # ---- Service Connections (names must match DevOps "Project Settings > Service connections")
  azureRMServiceConnection: 'AzureRM-ACR'          # ARM connection that can see the ACR
  kubernetesServiceConnection: 'AKSServiceConnection'
  sonarConnection: 'SonarQube Server local connection'

  mavenOpts: '-Xmx1024m'

stages:
# 1) Build + Test (+ optional Sonar)
- stage: Build_Test_Scan
  displayName: 'Build, Test & Sonar Scan'
  jobs:
  - job: MavenBuild
    displayName: 'Maven build & tests'
    steps:
      - checkout: self

      # Ensure JDK 17 is available even if the agent doesn't have JAVA_HOME_17_X64
      - task: UseJavaVersion@1
        displayName: 'Install JDK 17 (Temurin)'
        inputs:
          versionSpec: '17'
          jdkArchitectureOption: 'x64'
          jdkSourceOption: 'PreInstalled' # falls back to preinstalled; change to 'AzureStorage' only if you manage archives

      # (Optional) SonarQube – keep if you actually use it
      - task: SonarQubePrepare@5
        displayName: 'Prepare SonarQube'
        inputs:
          SonarQube: '$(sonarConnection)'
          scannerMode: 'Other'
          configMode: 'manual'
          extraProperties: |
            sonar.projectKey=$(imageRepository)
            sonar.projectName=$(imageRepository)
            sonar.java.source=17
            sonar.sourceEncoding=UTF-8
            sonar.coverage.jacoco.xmlReportPaths=**/jacoco*.xml

      - task: Maven@4
        displayName: 'Maven clean verify (tests + JaCoCo)'
        inputs:
          mavenPomFile: 'pom.xml'
          goals: 'clean verify'
          options: '-Dmaven.test.failure.ignore=false'
          publishJUnitResults: true
          testResultsFiles: '**/surefire-reports/TEST-*.xml'
          codeCoverageToolOption: 'JaCoCo'
          mavenOptions: '$(mavenOpts)'

      - task: SonarQubeAnalyze@5
        displayName: 'Run SonarQube Analysis'
        condition: succeeded()

      - task: SonarQubePublish@5
        displayName: 'Publish Quality Gate'
        inputs:
          pollingTimeoutSec: '300'
        condition: succeeded()

# 2) Build container in ACR (server-side) – no local Docker needed on the agent
- stage: ACR_Build
  displayName: 'Build image in ACR (az acr build)'
  dependsOn: Build_Test_Scan
  condition: succeeded()
  jobs:
  - job: ACRBuild
    displayName: 'ACR build: $(imageRepository):$(tag)'
    steps:
      - checkout: self

      # Use ARM service connection that has 'AcrPush' role on the registry subscription/resource
      - task: AzureCLI@2
        displayName: 'ACR build (aks-java-api:$(tag))'
        inputs:
          azureSubscription: '$(azureRMServiceConnection)'
          scriptType: 'ps'               # use 'ps' on Windows agent, 'bash' on Linux agent
          scriptLocation: 'inlineScript'
          workingDirectory: '$(Build.SourcesDirectory)'
          inlineScript: |
            az --version
            az acr show -n $(acrName) --query loginServer -o tsv

            # Build the image inside ACR from the repo context
            az acr build `
              --registry $(acrName) `
              --image $(imageRepository):$(tag) `
              --file Dockerfile `
              .

# 3) Deploy to AKS and wait for rollout
- stage: Deploy_AKS
  displayName: 'Deploy to AKS (demo)'
  dependsOn: ACR_Build
  condition: succeeded()
  jobs:
  - deployment: K8sDeploy
    displayName: 'K8s deploy'
    environment: 'aks-dev'
    strategy:
      runOnce:
        deploy:
          steps:
            - checkout: self

            # Idempotent namespace creation
            - task: Kubernetes@1
              displayName: 'Ensure namespace $(k8sNamespace)'
              inputs:
                connectionType: 'Kubernetes Service Connection'
                kubernetesServiceEndpoint: '$(kubernetesServiceConnection)'
                command: 'apply'
                useConfigurationFile: true
                configurationType: 'inline'
                inline: |
                  apiVersion: v1
                  kind: Namespace
                  metadata:
                    name: $(k8sNamespace)

            # (Optional) simple app secret – remove if you don’t use it
            - task: KubernetesManifest@1
              displayName: 'Create/Update app secret'
              inputs:
                action: 'createSecret'
                kubernetesServiceConnection: '$(kubernetesServiceConnection)'
                namespace: '$(k8sNamespace)'
                secretType: 'generic'
                secretName: 'app-secrets'
                secretArguments: |
                  --from-literal=APP_MESSAGE=Hello-from-Pipeline

            # Deploy manifests and override image with ACR image
            - task: KubernetesManifest@1
              displayName: 'Apply manifests (image override)'
              inputs:
                action: 'deploy'
                kubernetesServiceConnection: '$(kubernetesServiceConnection)'
                namespace: '$(k8sNamespace)'
                manifests: |
                  k8s/deployment.yaml
                  k8s/service.yaml
                containers: |
                  $(acrLoginServer)/$(imageRepository):$(tag)

            # Wait until the Deployment is Ready
            - task: Kubernetes@1
              displayName: 'Rollout status'
              inputs:
                connectionType: 'Kubernetes Service Connection'
                kubernetesServiceEndpoint: '$(kubernetesServiceConnection)'
                namespace: '$(k8sNamespace)'
                command: 'rollout'
                arguments: 'status deploy/aks-java-api --timeout=300s'

            # Show the service
            - task: Kubernetes@1
              displayName: 'Get service external IP'
              inputs:
                connectionType: 'Kubernetes Service Connection'
                kubernetesServiceEndpoint: '$(kubernetesServiceConnection)'
                namespace: '$(k8sNamespace)'
                command: 'get'
                arguments: 'svc aks-java-api -o wide'
